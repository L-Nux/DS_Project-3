# -*- coding: utf-8 -*-
"""Mood_upgrade Github.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w319igFBJKeG8M4VShJhniYxIDWii-zT
"""

pip install python-weather #tried with library

import pandas as pd #data processing
from pprint import pprint #“pretty-print” arbitrary Python data structures in a form which can be used as input to the interpreter
from collections import defaultdict #for the dictionary
import requests #allows to send HTTP requests using Python

departure = ['Essen', 'Heidelberg', 'Aachen', 'Bochum', 'Wuppertal', 'Würzburg',
       'Hagen', 'Erfurt', 'Solingen', 'Gelsenkirchen', 'Berlin',
       'Karlsruhe', 'Hamburg', 'Darmstadt', 'Dortmund', 'Stuttgart',
       'Nürnberg', 'München', 'Düsseldorf', 'Ulm', 'Köln', 'Mannheim',
       'Leipzig', 'Bonn', 'Oberhausen', 'Duisburg']
destination = ['Gelsenkirchen', 'Oberhausen', 'Bonn', 'Duisburg', 'München',
       'Bochum', 'Solingen', 'Nürnberg', 'Karlsruhe', 'Wuppertal',
       'Hagen', 'Dortmund', 'Düsseldorf', 'Essen', 'Erlangen',
       'Osnabrück', 'Leipzig', 'Würzburg', 'Mannheim', 'Ulm', 'Bamberg',
       'Darmstadt', 'Köln', 'Stuttgart', 'Heidelberg', 'Erfurt', 'Berlin',
       'Aachen', 'Hamburg'] #based on this list mostly
#create dictionary with cities IDs
cities_dict = {'Gelsenkirchen' : 2921466,
             'Oberhausen' : 2860410,
             'Bonn' : 2946447,
             'Duisburg' : 2934691,
             'München' : 2867714,
             'Bochum' : 2947416,
             'Solingen' : 2831580,
             'Nürnberg' : 2861650,
             'Karlsruhe' : 2892794,
             'Wuppertal' : 2805753,
             'Hagen' : 2912621,
             'Dortmund' : 2935517,
             'Düsseldorf' : 2934246,
             'Essen' : 2928810,
             'Erlangen' : 2929567,
             'Osnabrück' : 2856883,
             'Leipzig' : 6548737,
             'Würzburg' : 2805615,
             'Mannheim' : 2873891,
             'Ulm' : 2820256,
             'Bamberg' : 2952984,
             'Darmstadt' : 2938913,
             'Köln' : 2886242,
             'Stuttgart' : 2825297,  
             'Heidelberg' : 2907911,
             'Erfurt' : 2929670,
             'Berlin' : 2950159,
             'Aachen' : 3247449,
             'Hamburg' : 2911298}
departure.sort()
destination.sort()

"""Used openweathermapAPI, challenge- didnt return the data for the names of German cities written with umlaut- for some gave the data with English representative names, but not for all of them. Decided to use a dictionary to map city with ids and base API requests on ids"""

# a function for getting the weather properties
def get_weather(city_id):
  API_KEY = '...' #use a free generated key
  url = 'http://api.openweathermap.org/data/2.5/weather?id=' + str(city_id) + '&units=metric&appid=' + API_KEY
  r = requests.get(url)#api request
  # pprint(r.json())
  response = r.json() #parse the response
  return response['main']['temp'], response['main']['humidity'], response['main']['pressure'] #return the information for future df

#create new DF
df = pd.DataFrame([], columns = ['City', 'Temperature', 'Humidity', 'Pressure'])
df

for city in destination: #use cycle for the data stored in destination list
  temperature, humidity, pressure = get_weather(cities_dict[city]) #obtain values from the function
  df = df.append({'City': city, 'Temperature': temperature, 'Humidity': humidity, 'Pressure': pressure}, ignore_index=True) #append the requested values in dataframe

df# check

"""Depending on time and date of the request, the information obtained might be different, since its a dynamic incorporation

Warmer temperature is better for the customer.

Higher air pressure- weather is better, calmer
lower pressure-more windy and cloudy https://the-weather-station.com/how-does-air-pressure-affect-weather/

Good humifity level in general (30-50%), all the cities in Germany have bad (high) level of humidity,
97 for Aachen would be critical level,
higher humidity-the traveler feels worse, low energy, hyperthermia https://www.nbcnews.com/health/health-news/it-s-not-just-heat-it-really-humidity-know-risks-n629486
"""

#save weather dataset for further usage in common one
from google.colab import files
df.to_csv('weatherupdate.csv') 
files.download('weatherupdate.csv')

#mapping with common data set
#load common dataset without new feature
file='allfeatures.csv'
com= pd.read_csv(file)
print(com.describe())

#add the new columns for computations and alignments:
com['temperaturefrom'] = 0
com['temperatureto'] = 0
com['humidityfrom'] = 0
com['humidityto'] = 0
com['mood_upgrade'] = "null"

#add the new columns for computations and alignments:
com['pressurefrom'] = 0
com['pressureto'] = 0

#alignment with 2 data sets for temperature
for i in range(0, len(com)): #iterate
  for j in range(0, len(df)):
    if com ["sourcename"].values[i] == df ["City"].values[j]:
      com['temperaturefrom'].values[i] = df ["Temperature"].values[j]
    elif com ["targetname"].values[i] == df ["City"].values[j]:
      com['temperatureto'].values[i] = df ["Temperature"].values[j]

#alignment with 2 data sets for humidity level
for i in range(0, len(com)): #iterate
  for j in range(0, len(df)):
    if com ["sourcename"].values[i] == df ["City"].values[j]:
      com['humidityfrom'].values[i] = df ["Humidity"].values[j]
    elif com ["targetname"].values[i] == df ["City"].values[j]:
      com['humidityto'].values[i] = df ["Humidity"].values[j]

#alignment with 2 data sets for pressure
for i in range(0, len(com)): #iterate
  for j in range(0, len(df)):
    if com ["sourcename"].values[i] == df ["City"].values[j]:
      com['pressurefrom'].values[i] = df ["Pressure"].values[j]
    elif com ["targetname"].values[i] == df ["City"].values[j]:
      com['pressureto'].values[i] = df ["Pressure"].values[j]

com

#populate the dataframe "mood_upgrade" based on condition:

for i in range(0, len(com)): #iterate
  if com ["temperatureto"].values[i] > com ["temperaturefrom"].values[i]: #if temperature is higher the mood impoves 
      com['mood_upgrade'][i] = "achieved"
  elif com ["temperatureto"].values[i] < com ["temperaturefrom"].values[i]: #lower- the mood is getting worse
      com['mood_upgrade'][i] = "not_achieved"
  elif com ["temperatureto"].values[i] == com ["temperaturefrom"].values[i]: # if temperature is the same per OD-use additional conditions
      if com ["humidityto"].values[i] < com ["humidityfrom"].values[i] or com ["pressureto"].values[i] > com ["pressurefrom"].values[i]:
        com['mood_upgrade'][i] = "achieved"
      elif com ["humidityto"].values[i] > com ["humidityfrom"].values[i] or com ["pressureto"].values[i] < com ["pressurefrom"].values[i]:
        com['mood_upgrade'][i] = "not_achieved"
      else:
        com['mood_upgrade'][i] = "same" #if all 3 indicators per OD stay the same- the mood of the client is in the same range

"""Based on winter estimations (19th of December)"""

com #check the dataset with allfeatures

com.mood_upgrade.unique() #confirm, that we have all sets of unique values

com.isna().sum() #check any NaN-no missing values

"""no missing values in DF"""

#investigate the "same" mood value:
com.loc[com['mood_upgrade'] == 'same']

#investigate the "not_achieved" mood value:
com.loc[com['mood_upgrade'] == 'not_achieved']

com.loc[com['targetname'] == 'Karlsruhe'] #check the degree

com.drop('Unnamed: 0', axis=1, inplace=True)
com

"""for 183 rows from 85153 we have the same mood for the customer, when all 3 parameters are equal

checked not_achieved- to be correct with the values
"""


#check the density of values
m = com.mood_upgrade
counts = m.value_counts()
percent = m.value_counts(normalize=True)
percent100 = m.value_counts(normalize=True).mul(100).round(1).astype(str) + '%'
pd.DataFrame({'counts': counts, 'per': percent, 'per100': percent100})

"""the majority-60% is achieved, almost 40-not achieved, only 0,2-same value for the mood"""
